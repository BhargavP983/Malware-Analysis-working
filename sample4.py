import os
import magic
import hashlib
import yara
from pefile import PE
import string
import json
import lief

# Define the static_analysis function
def static_analysis(file_path):
    result = {}
    try:
        with open(file_path, 'rb') as f:
            file_data = f.read()
            filesize = len(file_data)
            filehash = hashlib.sha256(file_data).hexdigest()

            # Determining file type
            ftype = magic.from_file(file_path, mime=True)
            result["file_type"] = ftype

            # Calculate file size
            result["filesize"] = filesize

            # File Hash
            result["sha256"] = filehash

            if ftype.startswith("application/x-dosexec") or ftype.startswith("application/x-ms-dos-executable"):
                try:
                    pe = PE(data=file_data)
                    result["machine"] = hex(pe.FILE_HEADER.Machine)
                    result["magic"] = hex(pe.OPTIONAL_HEADER.Magic)

                    # Additional features extracted for PE files
                    result["number_of_sections"] = pe.FILE_HEADER.NumberOfSections
                    result["entry_point"] = pe.OPTIONAL_HEADER.AddressOfEntryPoint

                    # Extracting imports
                    imports = []
                    for entry in pe.DIRECTORY_ENTRY_IMPORT:
                        for imp in entry.imports:
                            if imp.name:
                                imports.append(imp.name.decode())
                    result["imports"] = imports

                    # Extracting exports
                    exports = []
                    if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                        for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                            exports.append(exp.name.decode())
                    result["exports"] = exports

                    sections = []
                    for section in pe.sections:
                        sections.append({
                            "name": section.Name.decode().strip('\x00'),
                            "virtual_address": hex(section.VirtualAddress),
                            "virtual_size": hex(section.Misc_VirtualSize),
                            "raw_size": hex(section.SizeOfRawData),
                            "entropy": section.get_entropy()
                        })
                    result["sections"] = sections

                except Exception as e:
                    print(f"Error analyzing {filename}: {e}")
            elif ftype.startswith("application/x-executable"):
                try:
                    # Open the binary with LIEF
                    binary = lief.parse(file_data)

                    # Extract header information
                    result["architecture"] = str(binary.header.architecture)
                    result["entrypoint"] = hex(binary.entrypoint)
                    result["format"] = binary.header.format

                    # Extract sections information
                    sections = []
                    for section in binary.sections:
                        sections.append({
                            "name": section.name,
                            "virtual_address": hex(section.virtual_address),
                            "size": hex(section.size),
                            "entropy": section.entropy
                        })
                    result["sections"] = sections

                    # Extract imported functions
                    imported_functions = []
                    if binary.imports:
                        for lib in binary.imports:
                            for imp in lib.entries:
                                imported_functions.append(imp.name)
                    result["imported_functions"] = imported_functions

                    # Additional features for other types of executables
                    # Extracting strings from executable
                    strings = []
                    for c in string.printable:
                        substr = bytes(c, 'ascii')
                        if substr in file_data:
                            strings.append(c)
                    result["strings"] = strings

                except Exception as e:
                    print(f"Error analyzing {filename}: {e}")
    except Exception as e:
        print(f"Error analyzing {filename}: {e}")
    return result

# Define the compare_with_yara function
def compare_with_yara(file_path, rules_file):
    matched_rules = []
    try:
        # Load YARA rule
        compiled_rule = yara.compile(filepath=rules_file)

        # Perform static analysis
        analysis_result = static_analysis(file_path)

        # Extract values from the feature dictionary
        features_values = [value for value in analysis_result.values()]

        # Convert values to a string
        features_str = '\n'.join(map(str, features_values))

        # Scan the data with the compiled rule
        matches = compiled_rule.match(data=features_str)

        # Extract the rule names from matches
        matched_rules = [match.rule for match in matches]

    except Exception as e:
        print(f"Error during YARA matching: {e}")

    return matched_rules

# Input folder path containing executable files
folder_path = input("Enter the folder path containing executable files: ")

# Input YARA rule file path
rules_file = input("Enter the path to the YARA rule file: ")

# Perform static analysis and YARA comparison for each file in the directory
for filename in os.listdir(folder_path):
    file_path = os.path.join(folder_path, filename)
    if os.path.isfile(file_path):
        matched_rules = compare_with_yara(file_path, rules_file)
        if matched_rules:
            print(f"File: {filename} - Matched YARA rules: {', '.join(matched_rules)} - **WARNING: Potential Malware Detected**")
        else:
            print(f"File: {filename} - No YARA rule matches found.")
