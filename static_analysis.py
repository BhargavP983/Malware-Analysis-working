import magic
import hashlib
from pefile import PE
import PyPDF2
import re
import string
import json


def static_analysis(filepath):
    result = {}

    with open(filepath, 'rb') as f:
        file_data = f.read()
        filesize = len(file_data)
        filehash = hashlib.sha256(file_data).hexdigest()

        # Determining file type
        ftype = magic.from_file(filepath, mime=True)
        result["file type"] = ftype
        # calculate File size
        result["filesize"] = filesize

        # File Hash
        sha256_hash = hashlib.sha256()
        sha256_hash.update(file_data)
        result["sha256"] = sha256_hash.hexdigest()

    if ftype.startswith("application/x-dosexec") or ftype.startswith("application/x-ms-dos-executable"):
        try:
            with open(filepath, 'rb') as f:
                pe = PE(data=file_data)
                result["machine"] = hex(pe.FILE_HEADER.Machine)
                result["magic"] = hex(pe.OPTIONAL_HEADER.Magic)

                # extra features extracted
                result["number_of_sections"] = pe.FILE_HEADER.NumberOfSections
                result["entry_point"] = pe.OPTIONAL_HEADER.AddressOfEntryPoint

        except Exception as e:
            print(f"Error analyzing PE headers of dos-exe: {e}")

    elif ftype.startswith("application/x-executable"):

        exported_functions = []
        for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
            exported_functions.append(exp.name)
        result["exported_functions"] = exported_functions

    elif ftype.startswith("application/pdf"):
        # Extract metadata
        with open(filepath, 'rb') as f:
            pdf_reader = PyPDF2.PdfReader(f)
            metadata = pdf_reader.metadata
            if metadata:
                result["metadata"] = {
                    "author": metadata.author,
                    "title": metadata.title,
                    "creation_date": metadata.creation_date,
                    "modification_date": metadata.modification_date,
                    "producer": metadata.producer
                }
            # Extract text content
                pdf_text = ""
                pdf_reader = PyPDF2.PdfReader(f)
                for page_num in range(len(pdf_reader.pages)):
                    page = pdf_reader.pages[page_num]
                    pdf_text += page.extract_text()
                result["text_content"] = pdf_text

            # Extract embedded files
            embedded_files = re.findall(rb"/EmbeddedFile.*?/Length (\d+)\s*>>\s*stream\s*(.*?)\s*endstream", file_data,
                                        re.DOTALL)
            result["embedded_files"] = [{"length": length.decode(), "data": data.decode().strip()} for length, data in
                                          embedded_files]

            # Extract object streams
            object_streams = re.findall(rb"(\d+) \d+ obj.*?endobj", file_data, re.DOTALL)
            result["object_streams"] = [{"object_number": str(obj_number), "data": str(obj_data).strip()} for
                                          obj_number, obj_data in object_streams]

            # Extract embedded URLs
            embedded_urls = re.findall(rb"(http[s]?://\S+)", file_data)
            result["embedded_urls"] = [url.decode() for url in embedded_urls]

            # Extract file structure
            file_structure = {}
            for obj_number, obj_data in object_streams:
                file_structure[obj_number.decode()] = obj_data.decode("latin1").strip()
            result["file_structure"] = file_structure

            # Extract embedded JavaScript
            embedded_js = re.findall(rb"<</S/JavaScript/JS\s*(.*?)>>", file_data)
            result["embedded_javascript"] = [js.decode("latin1") for js in embedded_js]


    return result


# Input file
# filepath = input("Enter the Filepath: ")
filepath = "Executables/file2.pdf"
# Perform static analysis
results = static_analysis(filepath)
for key, value in results.items():
    print(f"{key}: {value}")
